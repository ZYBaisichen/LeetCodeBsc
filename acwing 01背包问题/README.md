<!--
 * @Author: baisichen
 * @Date: 2021-05-05 17:13:22
 * @LastEditTime: 2021-05-05 19:38:40
 * @LastEditors: baisichen
 * @Description: 
-->
# 日期/类型
20210505 17点Z603火车上的总结 01背包问题
# 题目描述

## 来自背包九讲的描述
有N件物品和一个容量为V的背包，放入第i件物品耗费的费用为$C_i$，得到的价值为$W_i$，求解将哪些物品装入背包可以使得价值总和最大

# 思路(C++)
## 动态规划
一、初步分析
本问题的特点是：每种物品仅有一件，可以放也可以不放
   
二、状态定义
定义F[i][v]表示将前i个数放入容量为v的背包中产生的最大价值

三、状态转移
遇到第i个物品，背包容量为v时，可以选择放也可以选择不放，当选择放入第i个数时，产生的最大价值为前i-1个数放入$v-C_i$背包产生的最大价值加上当前第i个物品的价值，即：$F[i-1][v-V_i]+W_i$；
当选择不放第i个数时，因为不要求恰好将背包装满，所以产生的最大价值为前i-1个数放入背包为v产生的价值，即F[i-1][v]：
综上得出转移方程$F[i][v]=max(F[i-1][v-C_i]+W_i, F[i-1][v]) (1)$

四、初始化。
1. 将前0个物品装入背包时产生的价值为0，即F[0][v]=0, v=0,1,..,V
2. 第一个物品可以在循环中通过0加第一件物品的价值来计算，所以不用初始化

五、伪代码
``` cpp
F[i][0,...v] = 0;
for i = 1 to N:
   for v = 1 to V:
      $F[i][v] = max(F[i-1][v-C_i]+W_i, F[i-1][v])$
```

四、结果输出
最终输出为F[N][V], 因为不要求一定装满，但$v_2$会将$v_1$的结果传递过来，所以最终结构为F[N][V]是没问题的

### 复杂度
时间复杂度：O(N*V)。遍历n*V个数
空间复杂度：O(N*V) 借用F数组

### 空间复杂度优化
由于动态规划的本质是，在每次循环时根据前一个物品的状态计算当前物品的状态，所以可以使用一个一维数组来做状态的转移。用F[v]表示在第i-1个物品结束计算之后，每个重量下的背包所能产生的最大价值。通过看状态转移方程(1)式可以看出，F[i][v]只和F[i-1][v-C_i]还有F[i-1][v]有关，所以要么看它本身，要么往前看，故而需要将整个里层循环进行倒叙遍历，这样保证在取的时候里面存的值还是第i-1个物品放入背包产生的最大值，伪代码改为：
``` cpp
F[0,...v] = 0;
for i = 1 to N:
   for v = V to $C_i$:
      $F[v] = max(F[v-C_i]+W_i, F[v])$
```

- 下面将这个空间复杂度优化之后的代码抽象成一个函数，在以后的编程过程中可以直接调用，或写成一个宏来提高编程速度
``` cpp
def ZeroOnePack(F, C, W): //传参为dp数组，当前物品的花费、当前物品产生的价值
   for v = V to C:
      $F[v] = max(F[v-C]+W, F[v])$
```

- 综上，01背包问题的伪代码可以写成
``` cpp
F[0,...v] = 0;
for i = 1 to N:
   $ZeroOnePack(F, C_i, W_i)$
```