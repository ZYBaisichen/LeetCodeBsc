<!--
 * @Author: baisichen
 * @Date: 2021-05-05 17:13:22
 * @LastEditTime: 2021-05-07 10:32:19
 * @LastEditors: baisichen
 * @Description: 
-->
# 日期/类型
20210505 17点Z603火车上的总结 多重背包问题
# 题目描述

## 来自背包九讲的描述
有N种物品和一个容量为V的背包，第i种物品最多有$M_i$件可用，每件耗费费用为$C_i$, 价值是$W_i$。求解：将哪些物品装入背包，可以使这些物品耗费的费用总和不超过背包容量，且价值总和最大

# 思路(C++)
一、初步分析
和完全背包极度类似，将第i件物品的可以使用的数量从无限件变为了$M_i$件，所以需要对完全背包的基础思路的状态转移方程的取值做限定。
   
二、状态定义
定义F[i][v]表示将前i种物品，每种物品放入了k件产生的最大价值

三、状态转移
遇到第i种物品，背包容量为v时，可以选择放k件，放入之后产生的最大价值为，前i-1种物品放入容量为$v-k*C_i$时产生的最大价值加上放入的k件第i种物品的价值。
综上得出转移方程$F[i][v]=max(F[i-1][v-k*C_i]+k*W_i), k=0,1,...,min([v/C_i],M_i) (1)$

四、初始化。
1. 将前0种物品装入背包时产生的价值为0，即F[0][v]=0, v=0,1,..,V
2. 第一个物品可以在循环中通过0加第一件物品的价值来计算，所以不用初始化

五、伪代码
``` cpp
F[i][0,...v] = 0;
for i = 1 to N:
   for v = 1 to V:
      for k = 0 to $min([v/C_i], M_i)$:
         $F[i][v] = max(F[i-1][v-k*C_i]+k*W_i)$
```

四、结果输出
最终输出为F[N][V], 因为不要求一定装满，但$v_2$会将$v_1$的结果传递过来，所以最终结构为F[N][V]是没问题的

## 复杂度
时间复杂度：

两层循环求解每个状态，但每个状态求解时的时间已经不是常数了，而是$[v/C_i]$, 所以总的时间复杂度为$O(N*V*\sum(M_i))$， 其中[]表示向下取整

空间复杂度：O(N*V) 借用F数组

## 转换成01背包问题求解
一种简单的转换方法是，将第i件物品拆分成$M_i$个物品，然后对这些物品做01背包，这种方法会将$\sum(M_i)$的复杂度加到N上，即时间复杂度为$O(\sum(M_i)*N*V)$， 不会减少时间复杂度。

考虑二进制算法，把第i种物品拆分成若干件物品，每一件物品都有一个系数，其费用和价值是原来的费用和价值乘以这个系数。令这些系数分别为$2^0, 2^1, 2^2,...,2^(k-1),M_i-2^(k+1)$， k是满足$M_i-2^(k+1)>0$的最大整数。例如，如果$M_i$为13，相应的k为3，这种最多取13件的应该被分成系数为1,2,4,6的四件物品。

分成的这几件物品的系数和为M，表明不可能取多余$M_i$件的第i中物品。另外这种方法也能保证对于$0,..M_i$间的每个整数，均可以用若干个系数的和表示，证明可以分为$0,...2^(k-1)和2^k...M_i$两个阶段证明。见下文:"多重背包的二进制拆分证明"

这样就将第i种物品拆分成了$log(M_i)$件物品，将原问题转化为$O(N*V\sum(log(M_i))$的01背包问题。

### 优化后的伪代码
``` cpp
F[0,...v] = 0;
for i = 1 to N:
   $MultiplePack(F, C_i, W_i, M_i)$

def MultiplePack(F, C, W, M):
   if C*M>=V: //当物品件数消耗的费用超过背包总量，则为一个完全背包问题
      CompletePack(F, C, W)
   k = 1
   while k < M //对第i种物品进行拆分，每件物品费用为k*C,价值为k*M
      ZeroOnePack(F, k*C, k*W)
      M = M-k
      k=2*k
   ZeroOnePack(F, C*M, W*M) //M减到最后即为最后一件系数为$M_i-2^(k+1)$的物品，对其进行01背包
```
## 可行性问题O(VN)的算法
**这块没懂它想说什么，先放着吧，待遇到实际问题再说**
当问题是“每种有若干件的物品能否填满给定容量的背包”，只须考虑填 满背包的可行性，不需考虑每件物品的价值时，多重背包问题同样有O(VN)复杂度的算法。

例如，可以使用单调队列的数据结构，优化基本算法的状态转移方程，使每个状态的值可以以均摊O(1)的时间求解。

下面介绍一种实现较为简单的O(VN)复杂度解多重背包问题的算法。它的基本思想是这样的:设F[i, j]表示“用了前i种物品填满容量为j的背包后，最多还剩下几个第i种物品可用”，如果F[i,j] = −1则说明这种状态不可行，若可 行应满足0 ≤ F[i,j] ≤ Mi。
递推求F[i, j]的伪代码如下:
``` cpp
F[0,1...V] = −1 F[0,0]= 0
for i =1 to N:
   for j = 0 to V:
      if F[i − 1][j] ≥ 0:
         F[i][j] = $M_i$
      else
         F[i][j] = −1
    for j=0 to V−$C_i$
      if F[i][j] > 0
         F[i][j+$C_i$] = max{F[i][j+$C_i$],F[i][j]−1}
```
最终F [N ][0 . . . V ]便是多重背包可行性问题的答案。

## 多重背包的二进制拆分证明
pass 待补充

## 单调最值优化方法
查看多重背包的朴素状态转移方程：

$F[i][v]=max(F[i-1][v-k*C_i]+k*W_i), k=0,1,...,min([v/C_i],M_i) (4)$

将每种物品分别拆分成$min(V/C_i, M_i)$个数，转换成01背包问题，其状态转移方程为：

$F[v]=max(F[v-k*C_i]+k*W_i), k=0,1,...,min([v/C_i],M_i) (5)$

进一步的:

$$ \left\{
\begin{aligned}
F[v]=max(F[v-0*C_i]+0*W_i, F[v-C_i]+W_i, F[v-2C_i]+2W_i ..., F[v-k*C_i]+k*W_i) \\
F[v+C_i]=max(F[v+C_i-0*C_i]+0*W_i, F[v+C_i-C_i]+W_i, F[v+C_i-2C_i]+2W_i ..., F[v+C_i-k*C_i]+k*W_i) \\
\end{aligned}, 0<=k<=min(V/C_i, M_i)
\right.
$$

整理得：
$$ \left\{
\begin{aligned}
F[v]=max(F[v], F[v-C_i]+W_i, F[v-2C_i]+2W_i ..., F[v-k*C_i]+k*W_i) \\
F[v+C_i]=max(F[v+C_i]+0*W_i, F[v]+W_i, F[v-C_i]+2W_i ..., F[v-（k-1)*C_i]+k*W_i) \\
\end{aligned}, 0<=k<=min(V/C_i, M_i)
\right. (6)
$$

从上式可以看出，每次计算某一个重量v时，都会比较k+1个数求取最大值，并且这k+1个数服从差为$C_i$的等差数列。所有重量针对每种物品$C_i$，通过计算出所有对$C_i$取模之后值为$0,...,C_i$的重量产生的最大价值的状态，即可列举出当前物品的所有状态。

进一步的，由于模不同的花费相互之间的计算没有什么影响，所以每个取模相同的等差数列的计算都可以单独计算，外层按照模来循环计算。观察(6)式每次做下一次加$C_i$状态时， 都是k+1的窗口往后移动，里层循环每次加$C_i$，窗口滑动的数列为$F[v], F[v+C_i], F[v+2C_i] ..., F[v+k*C_i]$，用单调队列每次用O(1)的时间内求出窗口为k+1的F最大值, 且每滑动一次还需要加上$k*W_i$，因为放入了k件物品。

最后F[V]即为答案


### 实际代码例子
看到董晓老师的课程才明白是怎么回事(https://www.bilibili.com/video/BV1354y1C7SF?t=1130), 下面将他的代码贴出来：
``` cpp
//多重背包，单调队列优化
for (int i=1; i<=n ; i++) {
   memcpy(g, f, sizeof(f)); //需要在原来的状态上滑动，将f拷贝到g上，用g来从小到大更新f
   cin >> v >> w >> s; //体积、价值、数量
   for (int j=0; j<v; j++) { //分解成v个类，余数从0到v-1
      int h=0,t=-1; //用数组模拟队列，下方为队头，上方为队尾，初始队列为空，h>t。
      for (int k=j; k<=m; k++) { //对每个类使用单调队列，在g上滑动，队列q中存储的是g的下标，即体积大小
         if (h<=t && q[h]<k-s*w) { //k-s*w为窗口左边界的g的下标值，当队首的在窗口左边界的左边时，则需要出队
            h++;
         }
         if (h<=t) { //队中非空时更新f
            //队首元素对应的容量产生的最大价值加上放进去(k-q[h])/v件物品产生的最大价值和当前k的最大价值想比较取最大值
            f[k] = max(g[k], g[q[h]]+ (k-q[h])/v*w );
         }
         while (h<=t && g[k] >= g[q[t]]+(k-q[h])/v*w ) { //当前值比队尾值更有价值，队尾出队
            //其中队尾容量对应的价值为g[q[t]]，加上还可以放入(k-q[h])/v件物品后的最大价值还不如当前k容量产生的价值，而队尾容量在窗口中一定在当前容量k的左边，在窗口内不可能将其作为最大值了，所以需要出队，将队尾一直出队，直到找到一个当前容量k的价值小于队尾元素再加上所能放入的(k-q[h])/v件物品后产生的最大价值。
            t--;
         }
         q[++t]=k;//下标容量k入队，方便队头出队
      }
   }
}
cout << f[m];
```
### 复杂度:
时间复杂度：遍历N个数，对每个数的处理是遍历一遍体积V，每次遍历体积V是用的单调队列求最大值，复杂度是O(1)，所以总的时间复杂度为O(N*V)

空间复杂度：借用一个大小为V的dp数组， 所以空间复杂度为O(V)