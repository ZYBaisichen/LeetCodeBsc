<!--
 * @Author: baisichen
 * @Date: 2021-05-08 10:21:39
 * @LastEditTime: 2021-05-08 14:54:10
 * @LastEditors: baisichen
 * @Description: 
-->
# 日期/类型
20210508 二叉树

# 题目描述
给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

进阶：
    你只能使用常量级额外空间。
    使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。



# 思路(C++)
## BFS广度优先搜索
用队列，初始将根节点入队，广度优先遍历依次取出各个元素，然后将没个元素的往左链接。注意因为每一层的最后一个节点的next应该为NULL，所以每次应该处理一层，然后才能进入到下一层。

### 复杂度
时间复杂度：O(n)，可以认为访问了多少节点，时间复杂度就为多少
空间复杂度：O(n), 借用的队列最大为叶节点的数目，为n/2

## 递归求解
观察到每一层的任意节点的右方节点只有两种情况：
- 当右方节点和当前节点是属于同一个父亲时，在父亲层直接将他们两个进行连接
- 当右方节点和当前节点不属于同一个父亲时，因为是完美二叉树，所以两个父亲节点一定在上一层相邻，所以当前节点一定是其父节点的右节点，右方节点一定是其父节点的左节点，且他们的父亲节点在上一层已经连接到一起了，这里他们的父亲节点的连接也可以是这两种情况，为同一种情况，这样就可以用递归来做。
在当前层每次传入两个节点下去，表示要将node2连接到node1的后面，每个节点的两个左右子节点，以及node1的右节点和node2的左节点需要连接到一起。直到碰到子节点为空为止，注意这里因为是完美二叉树，所以当没有左节点时，一定也没有右节点。