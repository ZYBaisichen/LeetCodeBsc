<!--
 * @Author: baisichen
 * @Date: 2021-05-05 17:13:22
 * @LastEditTime: 2021-05-05 19:41:08
 * @LastEditors: baisichen
 * @Description: 
-->
# 日期/类型
20210505 17点Z603火车上的总结 完全背包问题
# 题目描述

## 来自背包九讲的描述
有N种物品和一个容量为V的背包，每种物品都有无限件可用，放入一件第i种物品的费用为$C_i$, 价值是$W_i$。求解：将哪些物品装入背包，可以使这些物品耗费的费用总和不超过背包容量，且价值总和最大

# 思路(C++)
一、初步分析
本问题在01背包的问题上加了条件，即每种物品都有无限件可以用。所以对于每一种物品，不是光取或不取两种可能，而是有可能取$0,1,,...,[V/C_i]$件，按照01背包的思路对状态转移方程进行改造来求解。
   
二、状态定义
定义F[i][v]表示将前i种物品，每种物品放入了k件产生的最大价值

三、状态转移
遇到第i种物品，背包容量为v时，可以选择放k件，放入之后产生的最大价值为，前i-1种物品放入容量为$v-k*C_i$时产生的最大价值加上放入的k件第i种物品的价值。
综上得出转移方程$F[i][v]=max(F[i-1][v-k*C_i]+k*W_i), k=0,1,...,[v/C_i] (1)$

四、初始化。
1. 将前0种物品装入背包时产生的价值为0，即F[0][v]=0, v=0,1,..,V
2. 第一个物品可以在循环中通过0加第一件物品的价值来计算，所以不用初始化

五、伪代码
``` cpp
F[i][0,...v] = 0;
for i = 1 to N:
   for v = 1 to V:
      for k = 0 to [v/C_i]:
         $F[i][v] = max(F[i-1][v-k*C_i]+k*W_i)$
```

四、结果输出
最终输出为F[N][V], 因为不要求一定装满，但$v_2$会将$v_1$的结果传递过来，所以最终结构为F[N][V]是没问题的

## 复杂度
时间复杂度：
两层循环求解每个状态，但每个状态求解时的时间已经不是常数了，而是$[v/C_i]$, 所以总的时间复杂度为$O(N*V*\sum([v/C_i]))$， 其中[]表示向下取整
空间复杂度：O(N*V) 借用F数组

## 转换成01背包问题求解
一种简单的转换方法是，由于第i物品最多可以放入$V/C_i$件，所以可以将每种物品拆分成$V/C_i$个物品，然后对这些物品做01背包，这种方法会将$\sum(V/C_i)$的复杂度加到N上，即时间复杂度为$O(\sum(V/C_i)*N*V)$， 不会减少时间复杂度，这样指明了将完全背包问题转换成01背包问题的思路：将一种物品拆成多件只能选0件或者1件的01背包中的物品。
更高效的转换方法是：把第i中物品拆成$C_i*2^k$，价值为$W_i*2^k$的若干物品，其中k取遍满足$C_i*2^k<=V$的非负整数。这种二进制的思想，不管最优策略选几件第i种物品，其件数写成二进制后，总可以表示成若干个$2^k$件物品的和，这样一来就把每种物品拆分成了$log([V/C_i])$，具体完全背包做二进制优化的数学解释可以参考下文的“完全背包问题为什么可以进行二进制的优化”

### 优化后的伪代码
``` cpp
F[0,...v] = 0;
for i = 1 to N:
   for v = $C_i$ to V:
      $F[v] = max(F[v-C_i]+W_i, F[v]) (2)$
```
**上述伪代码依旧需要$实际编代码调试一下，可能才能体会到为什么可以这样写。**下面将背包九讲中的解释抄过来:
为什么这样写可行？首先想一下为什么01背包中要按照v递减的次序来循环。让v递减是为了保证第i次循环中的的状态F[i,v]是由状态$F[i-1][v-C_i]$递推过来的，也就是说，这样也就保证了第i-1个物品不会再次被选用，每个物品都只会选择一次。保证在考虑"选入一件第i中物品"这种策略时，依据的是一个不可能选任何一件第i中物品的结果$F[i-1][v-C_i]$。而现在完全背包的特点恰是每种物品可以选择无限件，所以考虑加入一件第i种物品这种策略时，却需要一个可能已经选了一件到多件第i种物品的结果$F[i][v-C_i]$, 所以这里为什么必须采用v递增的顺序循环，也是这个伪代码可以成立的道理。
从另外一个角度想，当前第i种物品，选择可以是0件也可以是多件，当选择的件数为0件时最大价值等于前i-1种物品放入容量为v的背包中的最大价值；当选择多件时，选择当前件物品的最大价值等于前i种物品(包括已经选择的那些第i中物品)放入背包为$v-C_i$的背包中的最大价值加上当前这一件第i种物品的价值，即：$F[i,v]= max(F[i-1][v], F[i][v-C_i]+W_i) (3)$。将此方程编程一维的数组即是上述代码。

上面这两个循环可以颠倒，因为(2)式中，从空间上看，F[v]只向前依赖，只要在求下一个状态时前面状态已经求出即可，与i无关，当循环颠倒时，只是从横向填充编程了纵向填充

- 下面将这个优化之后的代码抽象成一个函数，在以后的编程过程中可以直接调用，或写成一个宏来提高编程速度
``` cpp
def CompletePack(F, C, W): //传参为dp数组，当前物品的花费、当前物品产生的价值
   for v = C to V:
      $F[v] = max(F[v-C]+W, F[v])$
```

- 综上，01背包问题的伪代码可以写成
``` cpp
F[0,...v] = 0;
for i = 1 to N:
   $CompletePack(F, C_i, W_i)$
```

## 完全背包为什么可以进行二进制的优化
pass 将word粘过来