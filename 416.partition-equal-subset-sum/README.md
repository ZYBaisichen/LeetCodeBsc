# 日期/类型
20210427 背包问题
# 题目描述
给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
``` cpp
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```


# 思路(C++)
## 动态规划
一、初步分析
要将数组进行分割两个子集，令两个子集的元素和相等。只需要找到一个数的组合使其等于sum/2即可。考虑到一些特殊场景：
   1. 当最大值maxSum>sum/2时，则一定找不到一个可以分割的子集，返回false；
   2. 数组长度n<2时则一定不可以被分割
   3. sum为奇数时则一定不可以被分割
   
二、状态定义
定义dp[i][j]表示再前i个数中，是否可以找到一个组合使其和为j。

三、状态转移
当遇到第i个数时，可以选也可以不选。
   1. 当nums[i]>j时，则一定不选, 是否能找到一个和为j的组合，取决于前i-1个数能否找到一个和为j的组合：dp[i][j]=dp[i-1][j]
   2. 当nums[i]<=j时，不选i时，前i个数是否能找到一个和为j的组合， 取决于前i-1个数能否找到一个和为j的组合：dp[i][j]=dp[i-1][j]
   3. 当选i时，前i个数是否可以找到一个组合使其和为j，则取决于有前i-1个数中存在一个组合使其和为j-nums[i]，即：dp[i][j]=dp[i-1][j-nums[i]]

三、初始化。
1. 当要的和为0时，只需要都不选就可以，所以dp[i][0]=0, i=0,1,2,...,n
2. 选取第一个数时，可以组成和为prices[0]的组合，即dp[1][nums[i]]
3. 其他状态初始为false

四、结果输出
最终输出为dp[n][sum/2]

# 复杂度
时间复杂度：O(n*target)。遍历n*target个数

空间复杂度：O(n*(sum/2)) 借用dp 