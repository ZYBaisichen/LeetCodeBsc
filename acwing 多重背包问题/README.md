<!--
 * @Author: baisichen
 * @Date: 2021-05-05 17:13:22
 * @LastEditTime: 2021-05-05 20:18:50
 * @LastEditors: baisichen
 * @Description: 
-->
# 日期/类型
20210505 17点Z603火车上的总结 多重背包问题
# 题目描述

## 来自背包九讲的描述
有N种物品和一个容量为V的背包，第i种物品最多有$M_i$件可用，每件耗费费用为$C_i$, 价值是$W_i$。求解：将哪些物品装入背包，可以使这些物品耗费的费用总和不超过背包容量，且价值总和最大

# 思路(C++)
一、初步分析
和完全背包极度类似，将第i件物品的可以使用的数量从无限件变为了$M_i$件，所以需要对完全背包的基础思路的状态转移方程的取值做限定。
   
二、状态定义
定义F[i][v]表示将前i种物品，每种物品放入了k件产生的最大价值

三、状态转移
遇到第i种物品，背包容量为v时，可以选择放k件，放入之后产生的最大价值为，前i-1种物品放入容量为$v-k*C_i$时产生的最大价值加上放入的k件第i种物品的价值。
综上得出转移方程$F[i][v]=max(F[i-1][v-k*C_i]+k*W_i), k=0,1,...,min([v/C_i],M_i) (1)$

四、初始化。
1. 将前0种物品装入背包时产生的价值为0，即F[0][v]=0, v=0,1,..,V
2. 第一个物品可以在循环中通过0加第一件物品的价值来计算，所以不用初始化

五、伪代码
``` cpp
F[i][0,...v] = 0;
for i = 1 to N:
   for v = 1 to V:
      for k = 0 to $min([v/C_i], M_i)$:
         $F[i][v] = max(F[i-1][v-k*C_i]+k*W_i)$
```

四、结果输出
最终输出为F[N][V], 因为不要求一定装满，但$v_2$会将$v_1$的结果传递过来，所以最终结构为F[N][V]是没问题的

## 复杂度
时间复杂度：
两层循环求解每个状态，但每个状态求解时的时间已经不是常数了，而是$[v/C_i]$, 所以总的时间复杂度为$O(N*V*\sum(M_i))$， 其中[]表示向下取整
空间复杂度：O(N*V) 借用F数组

## 转换成01背包问题求解
一种简单的转换方法是，将第i件物品拆分成$M_i$个物品，然后对这些物品做01背包，这种方法会将$\sum(M_i)$的复杂度加到N上，即时间复杂度为$O(\sum(M_i)*N*V)$， 不会减少时间复杂度。
考虑二进制算法，把第i种物品拆分成若干件物品，每一件物品都有一个系数，其费用和价值是原来的费用和价值乘以这个系数。令这些系数分别为$2^0, 2^1, 2^2,...,2^(k-1),M_i-2^(k+1)$， k是满足$M_i-2^(k+1)>0$的最大整数。例如，如果$M_i$为13，相应的k为3，这种最多取13件的应该被分成系数为1,2,4,6的四件物品。
分成的这几件物品的系数和为M，表明不可能取多余$M_i$件的第i中物品。另外这种方法也能保证对于$0,..M_i$间的每个整数，均可以用若干个系数的和表示，证明可以分为$0,...2^(k-1)和2^k...M_i$两个阶段证明。见下文:"多重背包的二进制拆分证明"
这样就将第i种物品拆分成了$log(M_i)$件物品，将原问题转化为$O(N*V\sum(log(M_i))$的01背包问题。

### 优化后的伪代码
``` cpp
F[0,...v] = 0;
for i = 1 to N:
   $MultiplePack(F, C_i, W_i, M_i)$

def MultiplePack(F, C, W, M):
   if C*M>=V: //当物品件数消耗的费用超过背包总量，则为一个完全背包问题
      CompletePack(F, C, W)
   k = 1
   while k < M //对第i种物品进行拆分，每件物品费用为k*C,价值为k*M
      ZeroOnePack(F, k*C, k*M)
      M = M-k
      k=2*k
   ZeroOnePack(F, C*M, W*M) //M减到最后即为最后一件系数为$M_i-2^(k+1)$的物品，对其进行01背包
```
## 可行性问题O(VN)的算法


## 多重背包的二进制拆分证明
pass 待补充