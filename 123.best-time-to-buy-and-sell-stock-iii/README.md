# 日期/类型
20210424 股票买卖问题iii

# 题目描述
给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

# 思路(C++)
## 动态规划
一、由于在买卖过程中最多只能完成两笔交易，因此在任意一天结束后的的状态只有以下几种：
   - 未进行过任何操作
   - 只进行过一次买的操作
   - 进行了一次买的操作和一次卖的操作，即完成了一笔交易
   - 在完成第一笔交易的前提下，进行了第二次买的操作
   - 完成了全部两笔交易
  
由于第一个状态的利润为0，可以不做考虑，对于剩下的状态的最大利润分别记为buy1,sell1,buy2,sell2，可以看出，第i天的状态只和前一天的状态有关，和再之前的状态无关，因为再之前的状态已经记录在了第i-1天里。

二、在已知了第i-1天的四种状态后，如何通过状态转移方程得到第i天的四个状态呢？
- 对于buy1，要么是在之前没有任何操作的前提下在第i天买了;要么是在之前买了(buy1')，但第i天没进行任何操作。即：buy1 = max(buy1', -prices[i])
- 对于sell1, 要么在之前买了一次buy1'的状态下在第i天卖出去了；要么在之前就已经卖了一次(sell1)，第i天不做任何操作。即：sell1=max(buy1'+prices[i], sell1')
- 对于buy2，要么是在之前已经完成过一次交易(sell1')，第i天买入；要么是在之前已经在完成第一笔交易的前提下进行了第二次买入(buy2')。即：buy2=max(sell1'-prices[i], buy2')
- 对于sell2， 要么是在之前完成了第二次买入(buy2')第i天卖出；要么是在之前已经完成了全部两笔交易。 即sell2 = max(sell2', buy2'+prices[i])

三、初始化。
在第一天结束后的四个状态为
buy1=-prices[0]；
sell1=0；（买卖在同一天利润为0）
buy2=-prices[0]; （第一天买入且卖出，然后再买入）
sell2=0;(第一天买入卖出再买入再卖出)

四、结果输出
因为最多进行两笔交易，而手上的股票必须是卖出去的才是利润最大的。所以最大利润为max(sell1, sell2, 0)。但由于sell1,sell2初始为0，所以不可能小于0，如果最优的情况下只进行了一次交易，也会因为可以再同一天买入并卖出这一宽松条件，将sell1的状态转移到sell2。所以最终利润最大的值为sell2

# 复杂度
时间复杂度：O(n)。遍历n天

空间复杂度：O(n) 借用四个状态变量


## 动态规划-左神

可能性：
1. 第i个股票不参与交易dp[i][j]=dp[i-1][j]
2. 第i个股票参与交易，如果是交易一定是第i个股票卖出才能获得最大利润(贪心)。
   a. dp[i][j-1]+arr[i]-arr[i] ， 在0到i做不超过j-1次交易的情况下，在第i位置买了然后卖掉，凑够第j次
   b. dp[i-1][j-1]+arr[i]-arr[i-1], 在0到i-1上做j-1次交易，并且最后买入是在i-1处，然后i处卖出，凑够j次
   ....
   k. dp[0][j-1]+arr[i]-arr[0], 在0到0上做j-1次交易，并且最后买入是在0处，然后在i处卖出，所获得的最大利润

   提取t=max(dp[i][j-1]-arr[i],dp[i-1][j-1]-arr[i-1], ..., dp[0][j-1]-arr[0])
   
   当求dp[i+1][j-1]时，只需要更新t=max(t, dp[i+1][j-1]-arr[i+1]), 然后寄就可以求出来dp[i+1][j] = max(dp[i][j], t+arr[i+1])。作为一次时间上的压缩，不用再枚举i...0了

