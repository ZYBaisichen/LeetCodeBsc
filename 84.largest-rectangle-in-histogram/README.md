<!--
 * @Author: baisichen
 * @Date: 2021-05-06 14:39:28
 * @LastEditTime: 2021-05-07 13:30:58
 * @LastEditors: baisichen
 * @Description: 
-->
# 日期/类型
20210507 单调栈
# 题目描述
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。
``` cpp
输入: [2,1,5,6,2,3]
输出: 10
```

# 思路(C++)
## 暴力思路
遍历每个矩形i，固定高为h[i]，向两边看，直到找到第一个比当前矩形小的元素j和k。这样j和k就确定了以高为h[i]的宽度的左右边界，求得面积为(j-k-1)*h[i]。
### 复杂度
时间复杂度:O(n^2)
空间复杂度:O(1)

## 单调栈方法
考虑从第i个矩形每次向两边看的时候，是要找左右两侧最近的高度小于h的柱子，这样两根柱子之间(不包含本身)即为i能扩展到的最远范围。

考虑i左侧的某根柱子j，当h[i]<h[j]，则再来一根i+1柱子往左看时，找到的第一个比h[i+1]小的柱子一定不是h[j]，因为j右边有i，当i+1往左看的过程中一定先看到i，这个时候j对于i之后的柱子就再也没有了作用。

所以维护一个可能作为i左边比它小的柱子的答案的数据结构，满足$h[j_1] < h[j_2] ... < h[j_n]$, 当遍历到i的时候, 这个结构中的数字一定在其左边，从$j_n$开始往左看， 找到第一个比h[i]小的值，其余值因为比h[i]大，所以i+1往做看的时候一定会被i挡住，所以比h[i]大的值都要移除，最后将i加入。这种先移除后加入的方法，可以用栈来实现

注意，这里只是往左找左边界，向右找右边界的时候只需要从后往前遍历即可，这样找到每根柱子的左右边界之后就可以以当前柱子为高的矩形面积。

### 边界值
当栈为空时要么还没进入过任何数字，要么是栈里的所有数字都比h[i]大。

### 复杂度
时间复杂度：O(n), 每个数字恰好入一次栈
空间复杂度：O(n)，当矩形高度为正序有序时，所有元素都将入到栈里面
