<!--
 * @Author: baisichen
 * @Date: 2021-04-27 14:19:05
 * @LastEditTime: 2021-04-27 19:49:28
 * @LastEditors: baisichen
 * @Description: 
-->
# 日期/类型
20210427 买卖股票的最佳时机含手续费
https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/

# 题目描述
给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。
``` cpp
示例 1:
输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
输出: 8
解释: 能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
```

# 思路(C++)
## 动态规划
一、初步分析
本次股票问题依旧是可以进行无限次交易，第i天结束后，手里要么有股票要么没股票；
新增一个条件是每次交易的时候需要收取固定的手续费，可以在买入的时候收取，也可以在卖出的时候收取。所以在状态转移时将手续费收取条件考虑进去就可以了。

二、 状态定义
用dp[i][0]表示第i天结束时手中没股票时的最大利润
用dp[i][1]表示第i天结束时手中有股票时的最大利润

三、状态转移
1. 当第i天结束时手里没股票时，则有可能是前一天就没股票；或者是在前一天有股票的情况下在当天进行了卖出，且卖出时收取了fee的手续费:dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i]-fee)
2. 当第i天结束时手里有股票时，则可能是前一天手里就有股票；或者是在前一天没有股票的情况下在当天进行了买入:dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])

三、初始化和边界。
- 第一天结束后有股票利润为dp[1][1]=-prices[0]；无股票的利润为0:dp[1][0]=0


四、结果输出
最后一天手中无股票状态的利润，dp[n][0]即为最终答案

### 复杂度
时间复杂度：O(n)。遍历n天

空间复杂度：O(2*n) 二维n