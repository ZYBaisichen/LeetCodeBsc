<!--
 * @Author: baisichen
 * @Date: 2021-04-28 11:14:23
 * @LastEditTime: 2021-04-29 13:41:31
 * @LastEditors: baisichen
 * @Description: 
-->
# 日期/类型
20210429 背包问题-完全背包
# 题目描述
给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 

``` cpp
输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```


# 思路(C++)
## 一、通用动态规划
一、初步分析
题目可以理解为，给一堆硬币coins，和一个总金额amount，通过找到所有组合，使每个组合的总金额恰好等于总金额amount。并最终给出有多少中组合。但因为同一种硬币可能放多个，当要拼成的总金额为j时，每一种硬币最多放j/coins[i]个。
所以这是一个典型的完全背包问题，但做了一下限制时恰好组成金额的组合数量

二、状态定义
定义dp[i][j]表示再前i中硬币中，能够得到金额为j的组合数

三、状态转移

当遇到第i种硬币时，因为组合没有顺序限制，所以对于每一种硬币都可以选择放k个(k=0,1,2,...,j/coins[i])，所以前i个硬币恰好能组成金额j的方法数为，在放不同数量的第i个硬币的情况下，前i-1种硬币能组成j-k*coins[i]金额的方法数之和，即:
dp[i][j] = sum(dp[i-1][j-k*coins[i]]), j>=k*coins[i]

三、初始化。
1. 组成0金额的方法数只有一种，就是什么都不取，即dp[i][0] = 1
2. 当选择第一个数时，每种k*coins[i]的金额的方法数为1，即dp[1][k*coins[i]]=1, k=0,1,2,..，amount/coins[i]

四、结果输出
最终输出为dp[n][target]

### 复杂度
时间复杂度：O(n*amount*(amount))。外层循环n*target个数，里层计算所有dp时最坏的情况下，硬币面额都为1， k从0循环到amount/1，所以最终复杂度为O(n*amount^2)

空间复杂度：O(n*amount) 借用dp
