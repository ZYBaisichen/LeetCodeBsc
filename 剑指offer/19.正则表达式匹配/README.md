<!--
 * @Author: baisichen
 * @Date: 2021-05-10 10:20:04
 * @LastEditTime: 2021-05-18 20:03:15
 * @LastEditors: baisichen
 * @Description: 
-->
# 日期/类型
20210513 字符串
本题与主站 10 题相同：https://leetcode-cn.com/problems/regular-expression-matching/

# 题目描述

请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。

``` cpp
示例 1:

输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```
s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 '*'。
注意：

# 思路(C++)

## 动态规划
一、初步分析
这个题属于正则表达式匹配，很容易让人联想到编译原理中的词法分析，可以借助非确定有限自动机来做初步分析。但这里有一点不同的是，词法分析中的文法是固定的，这里的匹配模式是变化的。

所以可以将其理解为两个字符串在某种匹配规则下相等即可。假设字符串为s, 匹配模式字符串为p, 当匹配到字符串的第i个字符s[i], 匹配模式的第j个字符p[j]时，能否匹配是可以根据前面的字符是否匹配算出来的，所以很容易联想到动态规划的方法

二、 状态定义
定义dp[i][j]表示长度为i的字符串和长度为j的字符串能否匹配。

三、状态转移
在没有.和*的情况下很好讨论，只需长度为i-1的字符串和长度为j-1的模式匹配，且s[i]==p[j]时即可，但假如了*和.之后就要分开讨论：

- 当p[j]为字母时，当s[i]==p[j]，取决于dp[i-1][j-1]， 转移方程为：

  $dp[i][j] = dp[i-1][j-1], st. s[i]==p[j]$
- 当p[j]为'.'时，则可以匹配任意的字母，完全取决于dp[i-1][j-1], 转移方程为：

 $dp[i][j] = dp[i-1][j-1], st. p[j]=='.'$

- 当p[j]为'*'时，可以将p[j]和p[j-1]合并为一个字符，p[j-1]可以匹配0个或多个, 当一个字母没匹配时，dp[i][j]取决于长度为j-2的模式能否匹配长度为i的字符串; 当匹配一个字母时，dp[i][j]取决于长度为j的模式串能否匹配长度为i-1的字符串；匹配k个字母时，dp[i][j]取决于长度为j的模式串能否匹配长度为i-k (k<=i)的字符串，故有以下转移方程：
$$
a^b \quad  = \left\{
\begin{aligned}
dp[i][j] = dp[i][j-2], 不匹配任何字符 \\
dp[i][j] = dp[i-1][j-2], st. s[i] == p[j-1] \\
dp[i][j] = dp[i-2][j-2], st. s[i-1]=s[i]==p[j-1] \\
dp[i][j] = dp[i-3][j-2], st. s[i-2]=s[i-1]=s[i]==p[j-1] \\
\cdots \cdots\cdots\cdots\cdots\cdots\cdots\cdots
\end{aligned}
\right.
$$

因为dp[i-1][j-2]也同样需要考虑模式串为星号、字母、点的情况，所以不一定是由dp[i-2][j-2]得来，不可以通过状态的传递性化简上述公式。从另外的角度考虑，假设*号及其前面的字母匹配能够匹配s[i]，则可以主动选择不匹配看长度为j-2的模式串能否匹配长度为i的字符串、选择匹配看长度为j的模式串能否匹配长度为i-1的字符串; 不能匹配s[i]则看长度为j-2个模式串能否匹配长度为i的字符串，有以下转移方程

$dp[i][j] = dp[i-1][j] or dp[i][j-2] st. s[i]==p[j-1] or p[j-1]=='.'$
$dp[i][j] = dp[i][j-2] st. s[i]!=p[j-1]$


四、初始化
- 空字符串和空模式是可以匹配的，所以dp[0][0]=true
- 空字符串和非空模式不一定匹配，所以无法确定
- 空模式和非空字符串一定不匹配

五、结果输出
dp[m][n]即为答案，其中m、n分别为字符串和模式串的长度

### 复杂度
时间复杂度：O(m*n)
空间复杂度：O(m*n)