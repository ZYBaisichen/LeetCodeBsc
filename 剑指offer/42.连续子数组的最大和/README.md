
<!--
 * @Author: baisichen
 * @Date: 2021-05-10 10:20:04
 * @LastEditTime: 2021-05-27 14:41:54
 * @LastEditors: baisichen
 * @Description: 
-->
# 日期/类型
20210527 动态规划

注意：本题与主站 53 题相同：https://leetcode-cn.com/problems/maximum-subarray/

# 题目描述
输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

示例1:

输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
 
提示：
1 <= arr.length <= 10^5
-100 <= arr[i] <= 100

# 思路(C++)

## 动态规划
一、初步分析
一开始想的是记录以第i个元素为开头的数组最大和，但题目要求数组里连续，无法往后继续再看元素，因为没有存储以后面的某一个数组为结尾的子数组的最大和，所以每次都需要遍历到整个数组的结尾才能求出最大连续子数组。

借鉴01背包的空间优化，从后往前看，每次求以第i个元素为结尾的连续子数组最大的和, 如果前面的最大和对于当前元素有负向效果，则抛弃，使用nums[i]本身作为最大和。

二、 状态定义
dp[i]表示已第i个元素为结尾的连续子数组的最大和

三、状态转移
以第i个元素为结尾的连续子数组的最大和，要么是其本身，要么加上前i-1个元素的连续子数组最大和，即：
dp[i] = max(nums[i-1], dp[i-1]+nums[i])

四、初始化
第一个元素为结尾的最大值为他本身：dp[1] = nums[0]

五、结果输出
由于和最大的连续子数组的最后一个元素不一定取到第n个元素，所以需要取dp[1]到dp[n]之间的最大值作为最大的连续子数组

### 复杂度
时间复杂度：O(n)

空间复杂度：O(n)

