# 日期/类型
20210509 递归、数组、大数、dp
# 题目描述
写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。


``` cpp
示例 1：
输入：n = 2
输出：1

示例 2：
输入：n = 5
输出：5

```
提示：

0 <= n <= 100

# 思路(C++)
## 递归

- 问题分解：
  要求第n个数，需要知道第n-1个数和n-2个数。

- 原子问题代码：核心代码就是最简单的那个问题的解决方案
``` cpp
求出第n-1个数和第n-2个数，第n个数等于他们两个之和
```

- 结束条件：第一个数为0，第二个数为1

### 复杂度
时间复杂度:$O(2^n)$， 列出二叉树，共有N层，节点数为$2^N$

## dp动态规划
一、初步分析
由于在递归过程中会有很多重复的计算，比如计算第10个数时需要计算第9和第8个数，而计算第9个数又需要计算第8和第7个数，计算第8个数需要计算第7和第6个数。所以能不能将中间结果存下来，即存储每个计算出来的第i项

二、 状态定义
定义dp[i]为第i项数字

三、状态转移
第i个数字为第i-2个数字和第i-1个数字计算得到

三、初始化
dp[1] = 0;
dp[2] = 1


四、结果输出
dp[n]即为第n项斐波那契数列

### 复杂度
时间复杂度：O(n)， 需要遍历计算从1到n的每一项’
空间复杂度：O(n)，借用长度为n的dp数组

## 待优化的动态规划
在更新状态的过程中发现，转移方程只用到了当前项的前两项，再往前的值没有使用，所以用两个数值来表示第前一项和第前两项。
### 复杂度
时间复杂度：O(n)， 需要遍历计算从1到n的每一项
空间复杂度：O(1)，借用两个整形变量



