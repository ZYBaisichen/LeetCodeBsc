<!--
 * @Author: baisichen
 * @Date: 2021-05-10 10:20:04
 * @LastEditTime: 2021-05-10 22:26:31
 * @LastEditors: baisichen
 * @Description: 
-->
# 日期/类型
20210510 DFS，递归，减枝、回溯

# 题目描述
地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？


``` cpp
示例 1：

输入：m = 2, n = 3, k = 1
输出：3

```


# 思路(C++)
## DFS+减枝
问题核心是



- 原子问题代码：
``` cpp
如果当前字母(i,j)和第k个字母匹配，置board[i][j]为'\0'
往左找第k+1个字母
往右找第k+1个字母
往上找第k+1个字母
往下找第k+1个字母
寻找结果做或运算得到最终结果
board[i][j]为原值
```

- 结束条件：
当前所在位置不在数组的范围内，并且k小于数组长度-1，返回FALSE
当前所在位置和word[k]不匹配时，返回false
当前board[i][j]为'\0'时，表示已经判断过，此路不通，返回false
k==len-1，返回true

### 复杂度
时间复杂度:$O(3^(len)*m*n)$

字符串长度为len，每次寻找有三种选择，舍弃回头的方向，查找的复杂度为$O(3^(len))$，矩阵中公有m*n个七点，时间复杂度为O(m*n)

空间复杂度：O(len)
搜索过程中递归深度不会超过len，系统栈空间占用K个

空间复杂度 O(K)O(K) ： 搜索过程中的递归深度不超过 KK ，因此系统因函数调用累计使用的栈空间占用 O(K)O(K) （因为函数返回后，系统调用的栈空间会释放）。最坏情况下 K = MNK=MN ，递归深度为 MNMN ，此时系统栈使用 O(MN)O(MN) 的额外空间。

