
<!--
 * @Author: baisichen
 * @Date: 2021-05-10 10:20:04
 * @LastEditTime: 2021-05-25 14:44:54
 * @LastEditors: baisichen
 * @Description: 
-->
# 日期/类型
20210525 数组
注意：本题与主站 169 题相同：https://leetcode-cn.com/problems/majority-element/

# 题目描述
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

示例 1:
输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]
输出: 2

限制：

1 <= 数组长度 <= 50000

 
# 思路(C++)

## 直观想法是排序
将数组进行排序，找到数组的中间位置即为多说元素

### 复杂度
时间复杂度：$O(n*log(n))$ 快排可以达到n*log(n)

空间复杂度：O(1)

## hash表
用一个hash表记录每个数字出现的次数，出现最多的那个即为超过半数的元素

### 复杂度
时间复杂度：O(n)

空间复杂度：O(n)


## 摩尔投票法
设输入数组 nums 的众数为 x，数组长度为 n。

推论一： 若记众数的票数为+1，非众数的票数为-1 ，则一定有所有数字的票数和>0。

推论二： 若数组的前a个数字的票数和=0，则数组剩余(n−a)个数字的票数和一定仍>0 ，即后(n-a)个数字的众数仍为x。

根据以上推论，记数组首个元素为 $n_1$，众数为x，遍历并统计票数。当发生票数和=0时，剩余数组的众数一定不变，这是由于：

当 $n_1 = x$时：抵消的所有数字，有一半是众数x。
当 $n_1 \neq x$时：抵消的所有数字，众数x的数量为一半或0个。
利用此特性，每轮假设发生 票数和=0都可以缩小剩余数组区间。当遍历完成时, 最后一轮假设的数字即为众数。

算法流程:
``` cpp
初始化： 票数统计 votes = 0 ， 众数x；
循环： 遍历数组 nums 中的每个数字 num[i]；
当票数votes等于0，则假设当前数字num[i]是众数x；
当num[i]=x时，票数votes自增1；当 num != x 时，票数 votes 自减 1 ；
返回值： 返回 x 即可；
```


