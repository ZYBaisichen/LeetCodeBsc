
<!--
 * @Author: baisichen
 * @Date: 2021-05-10 10:20:04
 * @LastEditTime: 2021-06-08 11:11:14
 * @LastEditors: baisichen
 * @Description: 
-->
# 日期/类型
20210610 递归

注意：本题与主站 110 题相同：https://leetcode-cn.com/problems/balanced-binary-tree/

# 题目描述
输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

 

示例 1:

给定二叉树 [3,9,20,null,null,15,7]

    3
   / \
  9  20
    /  \
   15   7
返回 true 。

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
返回 false 。

 

限制：

0 <= 树的结点个数 <= 10000


来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
# 思路(C++)

## 递归

一、自顶向下的遍历判断

判断当前是否左子树和右子树的高度差是否大于1， 只需先求出左子数的最大高度和右子树的最大高度，两者相减取绝对值，如果不大于1表示是平衡二叉树。

因为要求每个节点的左右子树深度差都不超过1，所以需要两层递归，每个节点调用depth函数

二、自底向上的遍历

> 看到海贼王大佬的题解，太神奇了，学习一下

每个树的深度为左右子树的最大值加1， 向上传递root的左右子树的高度；同时为了表示左右子树是否平衡，借助-1表示该子树为不平衡状态；计算完毕左右子树的高度后如果差小于等于1则为平衡二叉树





### 复杂度
时间复杂度：O(n）: 最差的情况下需要遍历所有N个节点

空间复杂度：O(N) ： 最差的情况下，树退化为链表的情况下，树的深度为N，需要使用O(N)的栈空间 
