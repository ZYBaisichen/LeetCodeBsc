
<!--
 * @Author: baisichen
 * @Date: 2021-05-10 10:20:04
 * @LastEditTime: 2021-05-25 08:50:30
 * @LastEditors: baisichen
 * @Description: 
-->
# 日期/类型
20210525 二叉树、链表
注意：本题与主站 426 题相同：https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/

# 题目描述
输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

为了让您更好地理解问题，以下面的二叉搜索树为例：
 
我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。

下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。


特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。


# 思路(C++)

## 递归指针操作
- 问题分解
  问题可以分解为将左右子树先全部转换成双向列表、然后将左边的最后一个节点的next指向当前root, 将root的next指向右边的第一个节点

- 原子问题代码：
``` cpp
左子树转换为双向列表，获得左子树的开头
右子数转换为双向列表，获得右子数的开头
左子树的结尾的下一个节点指向root，root的下一个节点指向右子数的开头
```

- 结束条件
  当前节点为空，则返回
- 查看运行栈
  
### 复杂度
时间复杂度：O(n^2) 遍历n个节点时每个节点都要从头开始遍历一遍

空间复杂度：O(1)

## O(n)的算法
增加一个pre节点，即当前链表的最后一个节点。

前序遍历，当前节点为空时返回；如果pre为空，则表示正在找头节点，则将head指向cur，否则pre和root双向连接，然后pre指向root