# 日期/类型
20210509 数组
# 题目描述
在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

``` cpp
现有矩阵 matrix 如下：
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
给定 target = 5，返回 true。
给定 target = 20，返回 false。
```

# 思路(C++)
## 暴力遍历
遍历二维数组中的所有元素，判断是否含有该整数
### 复杂度
时间复杂度：O(n*m), 最坏的情况下需要遍历整个数组
空间复杂度：O(1)

## 根据数组排序的特性遍历
由于数组是排序的，每一行从左到右递增排序，每一列从上到下递增排序。如果从左上角开始比，如果target比nums[0][0]大分不清是往右走看元素还是应该往下看元素。所以需要从右上角或者左下角开始看，相当于从每列的最大值和每行的最小值；或每列的最小值和每行的最大值开始看。

假设从右上角开始看，当target<nums[i][j]时，则当前列的下面的所有元素都是比target大的数，第j列就不用看了，往左移动，相当于减枝了n个元素；当target>nums[i][j]时，当前行左边的值都会比target小，减枝了m个元素，直到找到target为止，当i或j减到了-1还没有找到，则数组中不存在target

### 复杂度
时间复杂度：O(n-1+m-1)=O(n+m-2), 最多从右上角移动到左下角，横向移动判断了m-1步，纵向移动判断了n-1步
空间复杂度：O(1)