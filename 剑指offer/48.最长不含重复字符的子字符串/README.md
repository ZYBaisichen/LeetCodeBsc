
<!--
 * @Author: baisichen
 * @Date: 2021-05-10 10:20:04
 * @LastEditTime: 2021-06-07 17:43:41
 * @LastEditors: baisichen
 * @Description: 
-->
# 日期/类型
20210606 动态规划+哈希

# 题目描述
请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。

 

示例 1:

输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。




# 思路(C++)

## 动态规划+哈希表
一、初步分析

所有子字符串有n+(n-1)+(n-2)+...+1=(N+1)*N/2种，判断一个子字符串中是否有重复字符的复杂度为$O(N)$，总的时间复杂度为$O(n^3)$

用动态规划的方法做优化，存储遍历到每个元素的中间计算结果

二、 状态定义

定义dp[i]表示以s[i]为结尾无重复子字符串的长度

三、状态转移

假设我们每次知道了当前s[j]之前的每个字符最后出现的位置，就可以知道s[j]在之前最后出现的位置，如果没出现过，dp[i] = d[i-1] + 1

如果出现过，其位置为l，则需要比较dp[i-1]和i-l的值，如果dp[i-1]小于i-l，说明l在dp[i-1]所表示的最长字符串的左边，则dp[i] =  dp[i-1] + 1;当dp[i-1]大于i-l，说明l在dp[i-1]所表示的字符串的中间，dp[i] = i-l

总结下来公式为：

$$
dp[i] \quad  = \left\{
\begin{aligned}
dp[i-1]+1 \quad , \quad dp[i-1] < i-l \\
i-l \quad , \quad dp[i-1] >= i-l \\
\end{aligned}
\right.
$$

用哈希表tmp_map来记录字符最后出现的位置，取的时候直接用tmp_map[s[i]]取出来s[i]最后出现的位置。

四、初始化

以第一个字符为结尾的子串最长为1，所以dp[1] = 1

五、结果输出

f[n]即为输出答案

### 复杂度
时间复杂度：O(n)

空间复杂度：O(n)

