
<!--
 * @Author: baisichen
 * @Date: 2021-05-10 10:20:04
 * @LastEditTime: 2021-06-07 16:29:46
 * @LastEditors: baisichen
 * @Description: 
-->
# 日期/类型
20210606 动态规划

# 题目描述
在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？

 

示例 1:

输入: 
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 12
解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物

# 思路(C++)

## 动态规划
一、初步分析
从左上角开始往右下角遍历，最先想到的方法是dfs，遍历所有路径，然后得到路径和最大的值，往右最多n个元素，往下最多m个元素，长度为m+n的路径总数为$C_{m*n}^{m+n}$, 复杂度为$O((m+n)^2)$

使用动态规划思想进行优化，由于是从左上角开始往右下角遍历路径，所以对于以grid[i][j]为结尾的路径，上一个节点只可能从上面或左边过来，总路径和即为左边过来和上面过来的路径最大和加上grid[i][j]

二、 状态定义
定义dp[i][j]为已grid[i][j]为结尾的路径的最大和

三、状态转移
以当前节点为结束的路径的最大和为上面过来和左边过来的最大和路径加上当前节点
dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]

四、初始化
第一行只能从左边过来，dp[0][j] = dp[0][j-1] + grid[0][j]
第一列只能从上面过来，dp[i][0] = dp[i-1][0] + grid[i][0]

五、结果输出
dp[m][n]

六、空间复杂度优化
由于dp[i][j]做状态转移时，只用到了左边相邻的dp和grid、上面相邻的dp和grid，所以从上到下，从左到右计算时，跨越一行的grid的就用不到了，所以可以直接用grid当做dp数组。将额外空间复杂度降至O(1)

### 复杂度
时间复杂度：O(m*n)

空间复杂度：O(1)



