
<!--
 * @Author: baisichen
 * @Date: 2021-05-10 10:20:04
 * @LastEditTime: 2021-05-26 11:15:15
 * @LastEditors: baisichen
 * @Description: 
-->
# 日期/类型
20210525 字符串、dfs

# 题目描述
输入一个字符串，打印出该字符串中字符的所有排列。

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

示例:

输入：s = "abc"
输出：["abc","acb","bac","bca","cab","cba"]

限制：

1 <= s 的长度 <= 8

# 思路(C++)

## dfs搜索路径+set集合

dfs遍历字符串所有组合，然后加入集合中去重，最后放在vector中返回

用一个数组记录当前字母是否被访问过

- 问题分解：
  要想求字符串中的所有组合，枚举当前位置的所有之前没用过的字符。第一层有n-1种可能，第二层有n-2种可能，......

  所以递归过程是以当前节点为根节点，求出所有的路径

- 原子问题代码：核心代码就是最简单的那个问题的解决方案
``` cpp
枚举当前层节点
遍历到一个节点，将其加入到路径中，并将该节点置为已经访问
枚举下一层节点
枚举完当前节点从路径拿出，并将该节点置为未访问
```

- 结束条件：
   当路径长度恰好为源字符串长度时将遍历出的路径放在结果集中

- 查看运行栈

- 回溯
  - 遍历当前节点前将当前节点加入路径中，并将visited[i]设置为true
  - 以当前节点为根节点求得路径之后，将将visited[i]设置为false，将该节点从路径中取出

### 复杂度
时间复杂度：$O(2^n*long(n))$ 遍历$2^n$个节点，每次查找是否有重复元素最坏为log(n)

空间复杂度：O(n), 增加记录当前字符是否被访问过的数组记录
