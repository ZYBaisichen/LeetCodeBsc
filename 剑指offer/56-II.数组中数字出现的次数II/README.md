
<!--
 * @Author: baisichen
 * @Date: 2021-05-10 10:20:04
 * @LastEditTime: 2021-06-11 14:17:51
 * @LastEditors: baisichen
 * @Description: 
-->
# 日期/类型
20210611 位运算、状态机

# 题目描述
在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。

 

示例 1：

输入：nums = [3,4,3,3]
输出：4
示例 2：

输入：nums = [9,1,7,9,7,9,7]
输出：1
 

限制：

1 <= nums.length <= 10000
1 <= nums[i] < 2^31
 

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

# 思路(C++)
> 算法面试的优化过程其实就是从通用到定制的过程

## 直接统计各位上1出现的次数

对于每个数字循环和tmp相与，tmp左移一位，统计出对应位数上1的个数

每一位上对3取余，去掉所有出现三次的数的贡献（出现两次的时候，这种取余操作退化成异或操作）

将位数组回复成整数

### 复杂度分析
时间复杂度：O(n), 遍历所有数字，每个数字计算位数的复杂度固定为32，所以总体复杂度为O(N)

空间复杂度:O(1), 需要一个32大小的数组用于存储每一位出现一的个数

## 状态自动机（但不够通用，如果有四个状态还需要重新设置状态机）

对于每一位，当加进来一个0或1时，有三种状态：0、1、2，用两位来表示：00，01，10，分别看状态的每一位计算方法

（好吧，下面数字逻辑都还给老师了，对不起那位老人）

一、计算低位

``` cpp
if (high == 0) {
    if (in == 0 ) {
        low = low
    } 
    if (in==1){
        low = ~low 
    }
} else if(high == 1) {
    low = 0
}
```

异或化简(异或0为其本身，异或1位取反)：

``` cpp
if (high == 0) {
    low = low ^ in
} else if(high == 1) {
    low = 0
}
```

相与化简 (与1为其本身，与0为0)

``` cpp
low = low ^ in & ~high
```

二、在计算出低位的基础上计算高位

计算完低位的状态图为 01->00->10->01
``` cpp
if (low == 0) {
    if (in == 1) {
        high = ~high
    }
    if (in == 0) {
        high = high
    }
} 
if (low ==1) { 
    high = 0
}
```

异或化简
``` cpp
if (low == 0) {
    high = high ^ in
} 
if (low ==1) {
    high = 0
}
```

相与化简
high = high^in & ~low

三、返回值

上述是对二进制的某一位进行的分析，一个32位的整数每一位都有相同的运算规则，根据分配法运算规则可以直接作用在32位的整数上。出现三个数字的位数计算完毕之后最终状态会落到00上，只出现一次的数字状态只可能为00或01，所以最终high为0，low即为要求的数字

### 复杂度
时间复杂度：O(N），遍历N个元素计算高位和低位

空间复杂度：O(1)， 需要2个数字用来表示高位和低位
