
<!--
 * @Author: baisichen
 * @Date: 2021-05-10 10:20:04
 * @LastEditTime: 2021-05-27 11:45:00
 * @LastEditors: baisichen
 * @Description: 
-->
# 日期/类型
20210527 STL, 数学，大数据

注意：本题与主站 295 题相同：https://leetcode-cn.com/problems/find-median-from-data-stream/

# 题目描述
如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。

例如，

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：

void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。
示例 1：

输入：
["MedianFinder","addNum","addNum","findMedian","addNum","findMedian"]
[[],[1],[2],[],[3],[]]
输出：[null,null,null,1.50000,null,2.00000]
示例 2：

输入：
["MedianFinder","addNum","findMedian","addNum","findMedian"]
[[],[2],[],[3],[]]
输出：[null,null,2.00000,null,2.50000]
 

限制：

最多会对 addNum、findMedian 进行 50000 次调用。


# 思路(C++)

## 排序
每次一个数字进来之后，需要保证数列有序，每次都进行快排，log(n*log(n)), 然后如果数字的数量为奇数，取中间的数字为众数；如果数量为偶数，取中间的两个数的平均为中位数

### 复杂度
时间复杂度：每次进入一个数进行快排为O(n*log(n))， 取中位数的复杂度为O(1)

空间复杂度：O(n)

## 对顶堆栈
 数组一中位数为分隔点，左边的都比中位数小，右边的都比中位数大；而求中位数只需要知道左边的最大值和右边的最小值即可；所以维护两个堆，左边的元素放在最大堆里面，右边的元素房子啊最小堆里面；
 
 每次放入新的数字时，奇数次放入元素应该放入最大堆，但为了保证最大堆的元素都比最小堆的元素小，所以要先放入最小堆，然后从最小堆堆顶取出堆顶元素放在最大堆；偶数次放入元素应该放入右边的最小堆，但为了保证最小堆的元素都比最大堆的元素大，所以要先放入最大堆，然后取堆顶放入最小堆。

 每次取的时候，判断数组的元素的个数，为奇数时从最大堆中取堆顶；为偶数时从最大堆和最小堆中各取一个元素做平均

### 复杂度
时间复杂度：放入时每次堆调整为$O(log(n))$， 取出是O(1)

空间复杂度：O(n)
