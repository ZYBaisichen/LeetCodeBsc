
<!--
 * @Author: baisichen
 * @Date: 2021-05-10 10:20:04
 * @LastEditTime: 2021-06-13 17:27:23
 * @LastEditors: baisichen
 * @Description: 
-->
# 日期/类型
20210613 

# 题目描述
把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。

 

你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。

 

示例 1:

输入: 1
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
示例 2:

输入: 2
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
 

限制：

1 <= n <= 11



来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

# 思路(C++)

暴力枚举，每个骰子可能出现的点数有6个，总共有$6^n$种可能的组合，每种组合求出来后排序，最后得到概率。这样的复杂度太高

## 动态规划
一、初步分析

使用动态规划思想做优化。如果知道了前n-1个骰子每个组合的和的概率，只需要再乘上1/6（每种点出现的概率）

二、 状态定义

定义dp[i][j]为i个骰子出现和为j的概率

三、状态转移

假设当前出现的点数为x，则需要i-1个骰子的点数和为j-x, 概率为dp[i-1][j-x] * 1/6, 转移方程即为：dp[i][j] = dp[i-1][j-x]/6 , x=1,2,3,4,5,6

四、初始化
只有一个筛子时的概率为1/6，所以dp[1][x] = 1/6, x=1,2,3,4,5,6


五、结果输出

dp[n][x]即为答案， x=n...6*n

六、空间复杂度优化
由于n个骰子的各个点数只和的概率只和dp[n-k]有关，所以参考01背包的空间优化，可以用一个6*n的数组，每次从后往前更新，更新时dp[n-k]为前n-1个骰子和为n-k的概率

## 考虑离散型问题，有些点数和是不可能出现的。这个题是否可以求出n个骰子的概率分布呢？


## 复杂度分析

时间复杂度：需要遍历n个骰子，然后每个骰子计算次数为6*i-i, 最坏计算6n-n次，所以总的时间复杂度为$O(n^2)$

空间复杂度：优化之前用了二维数组，为$O(n^2)$， 优化之后用了一维数组大小为6n，空间复杂度为O(6*n)
