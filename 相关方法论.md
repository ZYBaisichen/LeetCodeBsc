# 相关方法论

# 递归
参考: [重建二叉树](剑指offer/07.重建二叉树)
递归的核心思想是分解。把一个很复杂的问题使用同一个策略将其分解为较简单的问题，如果这个的问题仍然不能解决则再次分解，直到问题能被直接处理为止。

比如求 1+1/2+1/3+...+1/n的和，如果按照我们正常的思维，就会使用一个循环，把所有的表示式的值加起来，这是最直接的办法。如果使用递归的思维，过程就是这样的，要求1+1/2+1/3+...+1/n的值，可以先求s1=1+1/2+1/3+...+1/(n-1)的值，再用s1加上1/n就是所求的值，而求s1的过程又可以使用上面的分解策略继续分解，最终分解到求1+1/2的值，而这个问题简单到我们可以直接解决，自此问题得到解决。

一般求解算法题目按照下面的过程来做：
- 问题分解：透过问题看本质，看到每个问题的核心，分解成能够解决的小问题

- 原子问题代码：核心代码就是最简单的那个问题的解决方案
``` cpp
建立root;
找到左子树的前序和中序结果子数组
找到右子树的前序和中序结果子数组
left = 建立左子树; 
right = 建立右子树;
```

- 结束条件：即为递归的出口，多为子问题再往下分解的非法条件
- 查看运行栈：可以在递归进入时打印每个的状态，比如
``` cpp
    TreeNode* buildTreeCore(vector<int>& preorder, int pre_s, int pre_e, vector<int>& inorder, int in_s, int in_e) { 
         cout << "status:" << pre_s << " " << pre_e << " "<< in_s << " "<< in_e<<endl;     
     }
```

# 动态规划
参考: [股票买卖问题](188.combination-sum-iv)
**分析出暴力解法，并在暴力解法之上做优化，将一些能够减枝的操作做保存就成了动态规划；然后进行状态定义；下面进行状态的更新，分析出在前一轮的状态变化的情况下当前的状态计算方法，即状态转移方程；最后给出答案**
一、初步分析
由于在买卖过程中最多只能完成K笔交易，因此在任意一天结束后的的状态，要么手里有股票，要么手里没股票。
其中有股票有两种情况，要么是在第i天当天完成第j次的买入操作，要么在前几天完成了第j次的买入操作(j=1,2,...k)
手里没股票有两种情况，要么是在第i天当天完成第j次的卖出操作，要么在前几天已经完成了第j次的卖出操作(j=1,2,...k)

对于每次交易，共有三种状态：未操作、买入、卖出。由于未操作产生的利润为0, 所以主要考虑每次交易的买入和卖出所产生的最大利润

二、 状态定义
用buy[i][j]表示第i天结束时完成了第j次交易的买入操作所获得的最大利润
用sell[i][j]表示在第i天结束时完成了第j次交易的卖出操作所获得的最大利润，即完成第j次交易所获得的最大利润

三、状态转移
buy[i][j]：在第i天第j次交易的买入操作，可能是前几天就已经完成了第j次交易的买入，还有可能是在前几天完成第j-1次交易之后再第i天当天买入，所以状态转移方程为：
``` cpp
buy[i][j] = max(buy[i-1][j],buy[i-2][j],..,buy[0][j], sell[i-1][j-1]-prices[i],sell[i-2][j-1]-prices[i],...,sell[0][j-1]-prices[i])
```
sell[i][j]：在第i天第j次交易的卖出操作，可能是前几天已经完成了第j次交易的卖出，还有可能在前几天完成了第j次交易的买入操作后再在第i天当天卖出，所以状态转移方程为：
``` cpp
sell[i][j] = max(sell[i-1][j],sell[i-2][j],..,sell[0][j], buy[i-1][j]+prices[i],buy[i-2][j]+prices[i],...,buy[0][j]+prices[i])
```
考虑buy[i][j]>=buy[i-1][j] => buy[i-1][j]>=buy[i-2][j] && sell[i][j]>=sell[i-1][j] => sell[i-1][j]>=sell[i-2][j] （1）
所以将上述方程进行简化：
``` cpp
buy[i][j] = max(buy[i-1][j], sell[i-1][j-1]-prices[i])
sell[i][j] = max(sell[i-1][j], buy[i-1][j]+prices[i])
```

三、初始化。
- 第0次交易的买入和卖出操作都没有意义，且都为0，所以buy[i][0]=sell[i][0]=0, i=1,2,...,n
- 第1天结束后第j次交易，买入则亏损prices[0]， 买入再卖出j次利润为0：buy[1][j] = -prices[0], sell[1][j]=0, j=1,2,...k
- 第i天结束后的第1次交易，买入亏损prices[i],但卖出暂时没法计算，所以buy[i][1] = -prices[i]


四、结果输出
因为最多进行k次交易，由公式(1)可以看到sell[i][j]是 一定大于sell[i-1][j]的；再考虑假如i天中只进行了j次交易，也会因为可以再同一天买入并卖出这一宽松条件，将sell[i][j]传递给sell[i][j+1]，所以最大利润值为sell[n][k]
