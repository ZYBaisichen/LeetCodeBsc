<!--
 * @Author: baisichen
 * @Date: 2021-05-10 10:20:04
 * @LastEditTime: 2021-06-22 11:50:56
 * @LastEditors: baisichen
 * @Description: 
-->
# 相关方法论

# 递归
参考: [重建二叉树](剑指offer/07.重建二叉树)
递归的核心思想是分解。把一个很复杂的问题使用同一个策略将其分解为较简单的问题，如果这个的问题仍然不能解决则再次分解，直到问题能被直接处理为止。

比如求 1+1/2+1/3+...+1/n的和，如果按照我们正常的思维，就会使用一个循环，把所有的表示式的值加起来，这是最直接的办法。如果使用递归的思维，过程就是这样的，要求1+1/2+1/3+...+1/n的值，可以先求s1=1+1/2+1/3+...+1/(n-1)的值，再用s1加上1/n就是所求的值，而求s1的过程又可以使用上面的分解策略继续分解，最终分解到求1+1/2的值，而这个问题简单到我们可以直接解决，自此问题得到解决。

一般求解算法题目按照下面的过程来做：
- 问题分解：透过问题看本质，看到每个问题的核心，分解成能够解决的小问题

- 原子问题代码：核心代码就是最简单的那个问题的解决方案
``` cpp
建立root;
找到左子树的前序和中序结果子数组
找到右子树的前序和中序结果子数组
left = 建立左子树; 
right = 建立右子树;
```

- 结束条件：即为递归的出口，多为子问题再往下分解的非法条件
- 查看运行栈：可以在递归进入时打印每个的状态，比如
``` cpp
    TreeNode* buildTreeCore(vector<int>& preorder, int pre_s, int pre_e, vector<int>& inorder, int in_s, int in_e) { 
         cout << "status:" << pre_s << " " << pre_e << " "<< in_s << " "<< in_e<<endl;     
     }
```

## 回溯&dfs
参考经典回溯问题-路径问题: [矩阵中的路径](剑指offer/12.矩阵中的路径)

回溯算法是一个递归的过程，具备通用的递归思想, 也具备跳出条件，具体操作，递归条件等元素

一、算法设计
回溯算法其实就是一个对决策树的遍历过程，需要思考 3 个问题：

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。

二、套路模板示例
``` cpp
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

三、经典问题
全排列问题、N皇后问题、矩阵路径问题

# 动态规划
参考: [股票买卖问题](188.combination-sum-iv)
**分析出暴力解法，并在暴力解法之上做优化，将一些能够减枝的操作做保存就成了动态规划；然后进行状态定义；下面进行状态的更新，分析出在前一轮的状态变化的情况下当前的状态计算方法，即状态转移方程；最后给出答案**
一、初步分析

使用公式或文字描述问题，并做思路的记录

二、 状态定义

定义动态规划的状态

三、状态转移

根据上一层的状态更新下一层的状态

四、初始化

定义动态规划的边界条件，初始状态下是什么

五、结果输出

分析出哪个状态是最终的答案

六、空间复杂度优化

动态规划的思想本质上是用空间来换时间，那么如何在不牺牲时间的前提下降低空间复杂度，就是本阶段需要思考的问题。典型的优化如[01背包问题的优化](acwing02.ZeroOnePack)、[剑指47](剑指offer/47.礼物的最大价值)

