# 日期/类型
20210423 每日一题
# 题目描述
根据题目描述，如果一个所有元素互不相同的集合中的任意元素存在整除关系，就成为整除子集


# 思路(C++)
0. 为得到一个最大的整除子集，考虑从一个小的整除子集扩充成为更大的整除子集
   0. 如果整数a是整数S1的最小整数的b的约数，那么a就可以添加到S1中得到更大的子集
   1. 如果c是S1最大整数d的倍数，那么c就可以添加到S1中得到更大的自己
   2. 以上两点具有问题的特点，且小的子集时的状态不会对大子集状态产生影响，可以用动态规划问题求解，和经典动态规划问题类似[300.最长递增子序列]()类似
1. 状态定义：将数组nums升序，方便获得一个子集的最小整数或最大整数，设置dp[i]表示在nums升序的情况下，以nums[i]为最大整数的整数子集的大小。（此时nums[i]为必选）
2. 状态转移方程(方程不一定只能用公式来表示，也可以用语言来描述)：枚举j=0,..,i-1的所有整数nums[j]，如果nums[j]能整除nums[i], 则nums[i]可以扩充在以nums[j]为最大整数的整除子集里成为一个更大的整除子集
3. 初始化：由于nums[i]必选，所以初始dp[i]=0,1,...,n
4. 输出：枚举dp找到最大的子集大小maxSize, 最大整数maxValue，按照如下方式倒推获得一个目标子集。（注意这里题目只需要输出一个最大子集，所以假如有多个最大子集大小为3，只需要找到其中一个就可以）
   1. 倒序遍历dp，找到dp[i]=maxSize, 把此时的nums[i]加入结果集，此时maxValue=mnums[i]
   2. 将maxSize的值减1，继续遍历找到dp[i]=maxSize， 且nums[i]能整除maxValue为止，将此时的nums[i]加入结果集，maxValue更新为nums[i]
   3. 重复上述操作，直到maxSize的值为0，此时的结果集即为一个目标子集

# 复杂度

时间复杂度：排序阶段为O(log(n));dp阶段为O(n^2);最后生成结果集阶段为O(n);所以最终复杂度为O(n^2)
空间复杂度：借用dp数组大小为n